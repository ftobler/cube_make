import os


tab = "\t"
backdash = "\\"
newline = "\n"


class MakefileGenerator:
    def __init__(self, project_path, config):
        self.project_path = project_path
        self.project_name = config["project_name"]
        self.source_paths = config["source_paths"]
        self.include_paths = config["include_paths"]
        self.defines = config["defines"]
        self.linker_script = config["linker_script"]
        self.prebuild_step = config["prebuild_step"]
        self.postbuild_step = config["postbuild_step"]
        self.convert_hex = config["convert_hex"]
        self.convert_bin = config["convert_bin"]
        self.optimization_level = config["optimization_level"]
        self.float_abi = config["float_abi"]
        self.cpu_arch = config["cpu_arch"]

    def _get_optimization_flag(self):
        if self.optimization_level == "com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.value.o0":
            return "-O0"
        elif self.optimization_level == "com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.value.o1":
            return "-O1"
        elif self.optimization_level == "com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.value.o2":
            return "-O2"
        elif self.optimization_level == "com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.value.o3":
            return "-O3"
        elif self.optimization_level == "com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.value.os":
            return "-Os"
        elif self.optimization_level == "com.st.stm32cube.ide.mcu.gnu.managedbuild.tool.c.compiler.option.optimization.level.value.ofast":
            return "-Ofast"
        else:
            return ""  # TODO either fail here or warn the user

    def _get_float_abi_flag(self):
        if self.float_abi == "com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.value.hard":
            return "-mfloat-abi=hard"
        elif self.float_abi == "com.st.stm32cube.ide.mcu.gnu.managedbuild.option.floatabi.value.soft":
            return "-mfloat-abi=soft"
        else:
            return ""

    def _find_sources(self, extension):
        found_files = []
        for source_path in self.source_paths:
            full_path = os.path.join(self.project_path, source_path)
            for root, _, files in os.walk(full_path):
                for file in files:
                    if file.endswith(extension):
                        relative_path = os.path.relpath(os.path.join(root, file), self.project_path)
                        found_files.append(relative_path)
        # Sort files based on their directory structure to match the desired order
        # application, then Core/Src, then Drivers
        return sorted(found_files)

    def generate(self):
        c_sources = self._find_sources('.c')
        cpp_sources = self._find_sources('.cpp')
        s_sources = self._find_sources('.s')

        # Define source variables as space-separated lists

        c_sources_var = self.format_file_list("C_SOURCES", c_sources)
        cpp_sources_var = self.format_file_list("CPP_SOURCES", cpp_sources)
        s_sources_var = self.format_file_list("S_SOURCES", s_sources)

        # Collect all unique source directories for VPATH
        all_sources = c_sources + cpp_sources + s_sources
        vpath_dirs = sorted(list(set(os.path.dirname(src) for src in all_sources if os.path.dirname(src))))
        vpath_var = "VPATH = " + ":".join(vpath_dirs) if vpath_dirs else ""

        # Format include paths and defines with -I and -D prefixes
        c_includes_var = self.format_file_list("C_INCLUDES", self.include_paths, prefix="-I")
        c_defines_var = self.format_file_list("C_DEFINES", self.defines, prefix="-D")

        hex_conversion_raw = "$(OBJCOPY) -O ihex $(BUILD_DIR)/$(PROJECT_NAME).elf $(BUILD_DIR)/$(PROJECT_NAME).hex"
        bin_conversion_raw = "$(OBJCOPY) -O binary $(BUILD_DIR)/$(PROJECT_NAME).elf $(BUILD_DIR)/$(PROJECT_NAME).bin"

        if self.convert_hex:
            hex_conversion = f"{tab}{hex_conversion_raw}"
        else:
            hex_conversion = f"# {hex_conversion_raw}"

        if self.convert_bin:
            bin_conversion = f"{tab}{bin_conversion_raw}"
        else:
            bin_conversion = f"# {bin_conversion_raw}"

        opt_level_flag = self._get_optimization_flag()
        float_abi_flag = self._get_float_abi_flag()

        makefile_content = f"""
# Makefile generated by eclipse_to_make

PROJECT_NAME = {self.project_name}

# Source files
{c_sources_var}
{cpp_sources_var}
{s_sources_var}

# VPATH for source directories
{vpath_var}

# Include paths
{c_includes_var}

# Defines
{c_defines_var}

# Linker script
LD_SCRIPT = {self.linker_script}

# Toolchain
CC = arm-none-eabi-gcc
CXX = arm-none-eabi-g++
AS = arm-none-eabi-as
LD = arm-none-eabi-gcc
AR = arm-none-eabi-ar
OBJCOPY = arm-none-eabi-objcopy
OBJDUMP = arm-none-eabi-objdump
SIZE = arm-none-eabi-size

# Flags
OPT_LEVEL = {opt_level_flag}
FLOAT_ABI_FLAG = {float_abi_flag}
CPU_ARCH_FLAG = -mcpu={self.cpu_arch}

C_FLAGS = \\
    $(CPU_ARCH_FLAG) \\
    -std=gnu11 \\
    -g3 \\
    -ffunction-sections \\
    -fdata-sections \\
    -Wall \\
    -fstack-usage \\
    --specs=nano.specs \\
    -mthumb \\
    $(OPT_LEVEL) \\
    $(FLOAT_ABI_FLAG)

CPP_FLAGS = \\
    $(CPU_ARCH_FLAG) \\
    -std=gnu++14 \\
    -g3 \\
    -ffunction-sections \\
    -fdata-sections \\
    -fno-exceptions \\
    -fno-rtti \\
    -fno-use-cxa-atexit \\
    -Wall \\
    -fstack-usage \\
    --specs=nano.specs \\
    -mthumb \\
    $(OPT_LEVEL) \\
    $(FLOAT_ABI_FLAG)

AS_FLAGS = \\
    $(CPU_ARCH_FLAG) $(FLOAT_ABI_FLAG) -mthumb

LD_FLAGS = \\
    -T$(LD_SCRIPT) \\
    $(CPU_ARCH_FLAG) \\
    --specs=nosys.specs \\
    -Wl,--gc-sections \\
    -static \\
    --specs=nano.specs \\
    -Wl,--start-group -lc -lm -lstdc++ -lsupc++ -Wl,--end-group \\
    -mthumb $(OPT_LEVEL) $(FLOAT_ABI_FLAG)

# Output directories
BUILD_DIR = build

# Object files
C_OBJECTS = $(patsubst %.c,$(BUILD_DIR)/%.o,$(notdir $(C_SOURCES)))
CPP_OBJECTS = $(patsubst %.cpp,$(BUILD_DIR)/%.o,$(notdir $(CPP_SOURCES)))
S_OBJECTS = $(patsubst %.s,$(BUILD_DIR)/%.o,$(notdir $(S_SOURCES)))

OBJECTS = $(C_OBJECTS) $(CPP_OBJECTS) $(S_OBJECTS)

.PHONY: all clean

all: $(BUILD_DIR)/$(PROJECT_NAME).elf

$(BUILD_DIR)/$(PROJECT_NAME).elf: $(OBJECTS)
{tab}@mkdir -p $(@D)
# pre build step
{tab}{self.prebuild_step}
{tab}$(LD) $(LD_FLAGS) $(OBJECTS) -o $@
{tab}$(SIZE) $@
# *.hex conversion
{hex_conversion}
# *.bin conversion
{bin_conversion}
# post build step
{tab}{self.postbuild_step}

# all targets for C (*.c) files
$(BUILD_DIR)/%.o: %.c
{tab}@mkdir -p $(@D)
{tab}$(CC) $(C_FLAGS) $(C_INCLUDES) $(C_DEFINES) -c $< -o $@

# all targets for C++ (*.cpp) files
$(BUILD_DIR)/%.o: %.cpp
{tab}@mkdir -p $(@D)
{tab}$(CXX) $(CPP_FLAGS) $(C_INCLUDES) $(C_DEFINES) -c $< -o $@

# all targets for assembly (*.s) files
$(BUILD_DIR)/%.o: %.s
{tab}@mkdir -p $(@D)
{tab}$(AS) $(AS_FLAGS) $< -o $@

clean:
{tab}rm -rf $(BUILD_DIR)

"""
        return makefile_content

    def format_file_list(self, key: str, file_list: list[str], prefix: str = "") -> str:
        if len(file_list) == 0:
            return f"# {key} = <list is empty>"

        # formatted_list = [f"{prefix}{item}" for item in file_list]
        formatted_list = []
        for item in file_list:
            # Escape make-unsafe characters by quoting the item
            if item == "":
                continue
            if any(c in item for c in [' ', '(', ')', '$', '#', '&', ';', '|', '<', '>', '*', '?', '[', ']', '{', '}']):
                formatted_list.append(f'"{prefix}{item}"')
            else:
                formatted_list.append(f"{prefix}{item}")
        return f"{key} = {backdash}{newline}{tab}" + (f" {backdash}{newline}{tab}".join(formatted_list))
