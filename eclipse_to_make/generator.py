import os

class MakefileGenerator:
    def __init__(self, project_path, project_name, source_paths, include_paths, defines, linker_script):
        self.project_path = project_path
        self.project_name = project_name
        self.source_paths = source_paths
        self.include_paths = include_paths
        self.defines = defines
        self.linker_script = linker_script

    def _format_list_for_display(self, items, prefix=""):
        if not items:
            return ""
        formatted_items = []
        for i, item in enumerate(items):
            if i < len(items) - 1:
                formatted_items.append(f"{prefix}{item} \\") # Double backslash for literal backslash
            else:
                formatted_items.append(f"{prefix}{item}")
        return "\n".join(formatted_items)

    def generate(self):
        c_sources = self._find_sources('.c')
        cpp_sources = self._find_sources('.cpp')
        s_sources = self._find_sources('.s')

        # Format source lists for Makefile variables (for display with line continuations)
        c_sources_formatted_vars = self._format_list_for_display(c_sources, "  ")
        cpp_sources_formatted_vars = self._format_list_for_display(cpp_sources, "  ")
        s_sources_formatted_vars = self._format_list_for_display(s_sources, "  ")

        # Generate object file names directly with BUILD_DIR prefix
        c_objects = [os.path.join("$(BUILD_DIR)", s.replace(".c", ".o")) for s in c_sources]
        cpp_objects = [os.path.join("$(BUILD_DIR)", s.replace(".cpp", ".o")) for s in cpp_sources]
        s_objects = [os.path.join("$(BUILD_DIR)", s.replace(".s", ".o")) for s in s_sources]

        all_objects = c_objects + cpp_objects + s_objects
        objects_formatted = " \
".join([f"  {obj}" for obj in all_objects])

        c_includes_formatted = self._format_list_for_display(self.include_paths, "  -I")
        c_defines_formatted = self._format_list_for_display(self.defines, "  -D")

        # VPATH for source directories
        vpath_dirs = " \
".join([f"  {path}" for path in self.source_paths])

        makefile_content = """
# Makefile generated by eclipse_to_make

PROJECT_NAME = {project_name}

# Source files (for display)
C_SOURCES = {c_sources_formatted_vars}

CPP_SOURCES = {cpp_sources_formatted_vars}

S_SOURCES = {s_sources_formatted_vars}

# VPATH for source directories
VPATH = {vpath_dirs}

# Include paths
C_INCLUDES = {c_includes_formatted}

# Defines
C_DEFINES = {c_defines_formatted}

# Linker script
LD_SCRIPT = {linker_script}

# Toolchain
CC = arm-none-eabi-gcc
CXX = arm-none-eabi-g++
AS = arm-none-eabi-as
LD = arm-none-eabi-gcc
AR = arm-none-eabi-ar
OBJCOPY = arm-none-eabi-objcopy
OBJDUMP = arm-none-eabi-objdump
SIZE = arm-none-eabi-size

# Flags
CFLAGS = -mcpu=cortex-m0plus -mthumb
CXXFLAGS = -mcpu=cortex-m0plus -mthumb
ASFLAGS = -mcpu=cortex-m0plus -mthumb
LDFLAGS = -T$(LD_SCRIPT) -mcpu=cortex-m0plus -mthumb

# Output directories
BUILD_DIR = build

# Object files
OBJECTS = {objects_formatted}

.PHONY: all clean

all: $(BUILD_DIR)/$(PROJECT_NAME).elf
	@mkdir -p $(@D)
	$(LD) $(LDFLAGS) $(OBJECTS) -o $@
	$(SIZE) $@

$(BUILD_DIR)/%.o: %.c
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) $(C_INCLUDES) $(C_DEFINES) -c $< -o $@

$(BUILD_DIR)/%.o: %.cpp
	@mkdir -p $(@D)
	$(CXX) $(CXXFLAGS) $(C_INCLUDES) $(C_DEFINES) -c $< -o $@

$(BUILD_DIR)/%.o: %.s
	@mkdir -p $(@D)
	$(AS) $(ASFLAGS) $< -o $@

clean:
	rm -rf $(BUILD_DIR)

""".format(
            project_name=self.project_name,
            c_sources_formatted_vars=c_sources_formatted_vars,
            cpp_sources_formatted_vars=cpp_sources_formatted_vars,
            s_sources_formatted_vars=s_sources_formatted_vars,
            objects_formatted=objects_formatted,
            c_includes_formatted=c_includes_formatted,
            c_defines_formatted=c_defines_formatted,
            linker_script=self.linker_script,
            vpath_dirs=vpath_dirs
        )
        return makefile_content

    def _find_sources(self, extension):
        found_files = []
        for source_path in self.source_paths:
            full_path = os.path.join(self.project_path, source_path)
            for root, _, files in os.walk(full_path):
                for file in files:
                    if file.endswith(extension):
                        relative_path = os.path.relpath(os.path.join(root, file), self.project_path)
                        found_files.append(relative_path)
        return sorted(found_files)