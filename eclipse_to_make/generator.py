import os

class MakefileGenerator:
    def __init__(self, project_path, project_name, source_paths, include_paths, defines, linker_script):
        self.project_path = project_path
        self.project_name = project_name
        self.source_paths = source_paths
        self.include_paths = include_paths
        self.defines = defines
        self.linker_script = linker_script

    def generate(self):
        c_sources = self._find_sources('.c')
        cpp_sources = self._find_sources('.cpp')
        s_sources = self._find_sources('.s')

        # Define source variables as space-separated lists
        c_sources_var = " ".join(c_sources)
        cpp_sources_var = " ".join(cpp_sources)
        s_sources_var = " ".join(s_sources)

        # Format include paths and defines with -I and -D prefixes
        c_includes_var = " ".join([f"-I{i}" for i in self.include_paths])
        c_defines_var = " ".join([f"-D{d}" for d in self.defines])

        # VPATH for source directories
        all_source_dirs = set()
        for source_file in c_sources + cpp_sources + s_sources:
            all_source_dirs.add(os.path.dirname(source_file))
        vpath_dirs = " ".join([path for path in sorted(list(all_source_dirs)) if path]) # Filter out empty string for root dir

        makefile_content = """
# Makefile generated by eclipse_to_make

PROJECT_NAME = {project_name}

# Source files
C_SOURCES = {c_sources_var}
CPP_SOURCES = {cpp_sources_var}
S_SOURCES = {s_sources_var}

# VPATH for source directories
VPATH = {vpath_dirs}

# Include paths
C_INCLUDES = {c_includes_var}

# Defines
C_DEFINES = {c_defines_var}

# Linker script
LD_SCRIPT = {linker_script}

# Toolchain
CC = arm-none-eabi-gcc
CXX = arm-none-eabi-g++
AS = arm-none-eabi-as
LD = arm-none-eabi-gcc
AR = arm-none-eabi-ar
OBJCOPY = arm-none-eabi-objcopy
OBJDUMP = arm-none-eabi-objdump
SIZE = arm-none-eabi-size

# Flags
CFLAGS = -mcpu=cortex-m0plus -mthumb
CXXFLAGS = -mcpu=cortex-m0plus -mthumb
ASFLAGS = -mcpu=cortex-m0plus -mthumb
LDFLAGS = -T$(LD_SCRIPT) -mcpu=cortex-m0plus -mthumb

# Output directories
BUILD_DIR = build

# Object files
C_OBJECTS = $(patsubst %.c,$(BUILD_DIR)/%.o,$(C_SOURCES))
CPP_OBJECTS = $(patsubst %.cpp,$(BUILD_DIR)/%.o,$(CPP_SOURCES))
S_OBJECTS = $(patsubst %.s,$(BUILD_DIR)/%.o,$(S_SOURCES))

OBJECTS = $(C_OBJECTS) $(CPP_OBJECTS) $(S_OBJECTS)

.PHONY: all clean

all: $(BUILD_DIR)/$(PROJECT_NAME).elf

$(BUILD_DIR)/$(PROJECT_NAME).elf: $(OBJECTS)
	@mkdir -p $(@D)
	$(LD) $(LDFLAGS) $(OBJECTS) -o $@
	$(SIZE) $@

$(BUILD_DIR)/%.o: %.c
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) $(C_INCLUDES) $(C_DEFINES) -c $< -o $@

$(BUILD_DIR)/%.o: %.cpp
	@mkdir -p $(@D)
	$(CXX) $(CXXFLAGS) $(C_INCLUDES) $(C_DEFINES) -c $< -o $@

$(BUILD_DIR)/%.o: %.s
	@mkdir -p $(@D)
	$(AS) $(ASFLAGS) $< -o $@

clean:
	rm -rf $(BUILD_DIR)

""".format(
            project_name=self.project_name,
            c_sources_var=c_sources_var,
            cpp_sources_var=cpp_sources_var,
            s_sources_var=s_sources_var,
            vpath_dirs=vpath_dirs,
            c_includes_var=c_includes_var,
            c_defines_var=c_defines_var,
            linker_script=self.linker_script
        )
        return makefile_content

    def _find_sources(self, extension):
        found_files = []
        for source_path in self.source_paths:
            full_path = os.path.join(self.project_path, source_path)
            for root, _, files in os.walk(full_path):
                for file in files:
                    if file.endswith(extension):
                        relative_path = os.path.relpath(os.path.join(root, file), self.project_path)
                        found_files.append(relative_path)
        return sorted(found_files)